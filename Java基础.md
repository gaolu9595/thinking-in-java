## Java编程基础😁

### 😉相关概念
JDK: Java Development Kit (包含JRE，同时包括client和server端的)
JRE: Java Runtime Enviorment (只包含client运行环境下的JVM：jre/bin/client/jvm.dll)
IDE: Integrated Development Enviorment (e.g. Eclipse)
问题空间（一项业务）<=============>   解空间（计算机）

### 😍(Object-oriented Programming）OOP基本思想
1. 👌**万物皆为对象**👌
2. 程序是对象的集合
3. 每个对象都有自己的由其他对象所构成的存储
4. 每个对象都有其类型（class），某一特定类型的所有对象都可以接收相同的消息
5. ***示例***：创建了一个Student类型的对象，定义了该对象的引用s，同时对s发送getAge消息请求。
 `Student s = new Student; 
 s.getAge()`
8. 每个对象都提供服务，程序应该被理解为：通过调用其他对象提供的服务，来为用户提供服务
9. 良好的OOP中，每个对象都可以很好的完成一项任务，但是它并不试图做更多的事
10. 类创建者对类消费者（客户端程序员）隐藏具体实现，只暴露必需的部分【访问控制能便于维护+减轻开发任务，Java用关键字public、private、protected来设定*****类的边界*****，Java还设置了*****包访问权限*****】
11. 🔥 **继承** 🔥（is-a和is-like-a关系）与**组合**
12. ❓❓❓ **多态** [在OOP中编译器无法产生传统意义上的函数调用，即“前期绑定”，Java缺省使用动态的“后期绑定”]--------向上转型upcasting*❓❓❓
13. 所有的类最终都继承于Object类（单根继承结构）
14. 🔥 **容器** 🔥（e.g. C++的STL等；Java提供的诸多类似List/Map/Set等的容器，以及队列/树/堆栈等多种构件）【只需要创建一个容器对象，让它处理所有细节，而不需要管将来会将多少个对象置于容器中】
15. 范型：创建一个容器并让它知道自己保存的对象的具体类型（非Object类型），避免向下转型的不安全性
16. 🔥 **对象的创建与生命周期** 🔥：Java采用完全动态内存分配的方式，只能在堆上new一个对象，并且采用垃圾回收器机制（注：内存池---->堆）
17. **异常处理**与**并发编程**
18. C/S模式

| 客户端 | 服务器端 | 前端开发(界面) |
|--|--|--|
| 安卓/IOS/PC开发/浏览器(JS,Applet) | Web服务器，Servlet及JSP | HTML/CSS |


###  📝Java程序设计
1. 数据**存储**到什么地方：寄存器(处理器内部)、堆栈、堆(memory pool，所有Java对象)、常量存储(程序内部)、非RAM存储(e.g.持久化对象和流对象)
2. Java**基本数据类型**[强类型语言]：（每个基本数据类型都有自己的包装类）
| boolean | char | byte | short | int | long | float | double | void |
3. **类(class)**：程序员定义的新数据类型【字段+方法】
4. **static**修饰的方法和字段是不依赖于类的对象而存在的，可以直接通过类名来访问，是没有this的方法。不论创建多少个对象，静态数据都只占用一份存储区域
5. **类的数据成员能被Java自动初始化**，而方法中的局部变量则不能，需要程序员手动初始化
6. 🔥 **“==”和“equals()”的区别** 🔥：前者比较的是基本数据类型的数值和引用类型的“对象地址”；后者不能用来比较基本数据类型，而在一些引用类型（未重写equals时）中比较“对象地址”，在另一些（重写了equals时，如String，Date，包装器类型）中比较对象的值。
7. 基本类型存储的是实际的数值，而并非指向一个对象的引用；而引用类型则不是这样（易出现“  *别名现象*  ”）
8. a++和a--：先赋值再计算； ++a和--a：先计算再赋值
9. 使用逻辑操作符时，“短路”的发生可以获得潜在的性能提升
10. BigInteger和BigDecimal是用于int和float高精度计算的两个类，支持任意精度的整数和浮点数，计算值不丢失任何信息；但是需要用方法调用来取代运算符实现运算，所以会慢一些
11. 单精度浮点数的表示范围（4bytes）：-3.40E+38~3.40E+38
12. 双精度浮点数的表示范围（8bytes）：-1.79E+308~-1.79E+308
13. Java中的小数默认是double类型，若需得到float类型要进行类型转换
14. **二进制编码**（原码---反码---补码）
15. 通常，表达式中出现的最大的数据类型决定了表达式最终的数据类型（e.g. 将一个float值和一个double值相乘，结果是double）；只要比int小的类型（char，byte和short），在运算之前，值都会自动转换成int
16. Java中包含的控制执行语句主要有“if-else, while, do-while, for, foreach, return, break, continue, switch-case”，不支持goto语句
17. **构造方法**：每个类都有至少一个构造方法，若没有显示定义一个构造方法，编译器会自动创建一个默认构造器（无参）；而若显示定义了构造方法，默认构造器就不会被创建。*除构造方法外，Java编译器中禁止在其他任何方法中调用构造方法*。      **方法重载**。
18. this关键字，用于在方法的内部获得对当前对象的引用；可以解决参数名和数据成员名相同时出现的歧义问题
19. finalize方法（终结处理）是危险的，多余的【垃圾回收】
20. 在类的内部，变量定义的先后顺序决定了初始化的顺序(**先静态对象，再非静态对象**)，即使变量定义散布于方法定义间，它们依旧会*在任何方法（包括构造方法）被调用之前*就得到初始化 
21. 对象的创建过程 [e.g. HelloLulu/src/constructor/StaticInitialization.java]
22. package和import关键字允许程序员做的，是将单一的全局名字空间分割开，使得不论多少人使用Internet（因为在发布Java程序时，package的名称一般使用反顺序的域名）和Java编写类都不会出现名称冲突的问题
23. 访问权限控制可以确保不会有任何客户端程序员依赖于某个类的底层实现的任何部分，也能简化他们对类的理解
24. 🔥 **Java访问权限修饰词** 🔥：包访问权限（无任何访问权限修饰时）；public（该成员声明自己对每个人都是可用的）；private（除了包含该成员的类外，其他任何类都无法访问这个成员）；protected（继承访问权限+包访问权限）
25. Java中的类仅有public和包访问权限两个选择。如果不希望任何其他人访问该类，可以将类中所有的构造方法设置为private，阻止任何人创建类的对象。
26. **组合与继承** 
27. 【继承时，创建的导出类的对象中，包含了一个基类的子对象】Java会自动在导出类的构造器中插入对基类默认构造器的调用，且这种调用是从基类“向外”扩散的。（基类构造器有参数列表时，要显示调用super()）
28. *代理*------>将成员对象置于要构造的类中，并且在新类中暴露该成员对象的底层部分方法子集，使用新类的方法来这些方法。
29. try{}finally{}，try关键字下面的块是保护区，表示需要被特殊处理，其中一项特殊处理就是“不论try块如何退出，finally子句中的代码总是要被执行”
30. **重载与重写**
31. **final**关键字：从设计角度来决定是否使用final，而不要从性能角度
 - *修饰字段*：一个永不改变的编译时常量；一个在运行时被初始化的且不能被改变的数值或者引用
 - *修饰参数*：保证在方法中无法更改final修饰的参数（数值/引用）
 - *修饰方法*：锁定方法，防止任何继承类重写
 - *修饰类*：永远不能被继承（因为final类禁止继承，因此final类中所有方法都隐式指定为final，因为无法覆盖他们）
32. 继承与初始化过程[e.g. HelloLulu/src/Inheritance/Test.java]
33. 对象的清理是按创建对象的逆序完成的
34. 👉👉👉 **多态** 👌👌👌
 - 动态绑定（后期绑定）【编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体并加以调用】，Java中除了**static方法(构造器是隐式的static方法)和final方法**(private包括其中)以外，其他所有方法都执行后期绑定；
 - Java是通过Class对象执行其RTTI（Run-time Type Identification）来实现多态的
 - 注意：任何域访问操作都将由编译器解析，因此不是多态的
 - ======>所以，**一般将域设置为private，然后通过get和set方法来访问**

 34. **编写构造器时的一条有效准则**（尽量做到）：用尽可能简单的方法使对象进入正常状态，若可以的话，避免调用其他方法【在构造器内，唯一能安全调用的是基类的final方法】。
 35. 继承中，向上转型是安全的，但会丢失类型信息；向下转型是有风险的(Java中使用RTTI[运行时类型检查]来保证安全)，但是可以获取具体类型信息。
 36. **Java中所有类都有一个Class类的对象**。 所有类都继承于java.lang.Object类
 37. 抽象类：不一定含有抽象方法，但是具有一个或多个抽象方法的类必须声明为抽象类。继承抽象类时可以不实现其所有抽象方法，这样的话子类也必须声明为抽象类。抽象类是不能创建实例对象的。
 38. 接口：相当于一个完全抽象的类，其中所有域都隐式地定义为static和final。在实现一个接口时，在接口中被定义的方法必须被定义为public。接口可以降低方法与类之间的耦合。
 39. **接口与抽象类的使用场景**【接口可以支持多实现，达到多重继承的效果；抽象类可以将每个子类都具有相同实现的方法声明为非抽象方法，减少冗余；接口可以实现方法与具体实现的完全分离，更利于代码调试和维护；抽象类可以保证类与类之间的层级关系，但是也可能使类与类之间耦合度过高，继承过于复杂】
 40. 内部类与匿名内部类
 41. java**中基本类型和包装类的区别**：
	 - 包装类是对象,拥有方法和字段.对象的调用都是通过引用对象的地址 ;
	 - 包装类创建的是对象，拥有方法和字段.对象的调用都是通过引用对象的地址 ; 基本类型不是.
	 - 包装类是引用传递 而基本类型是值传递 ;
	 - 变量的值存储在栈里，而对象存储在堆里，相比而言，堆栈更高效，这也是java保留基本类型的原因。包装类创建的对象，可以使用api提供的一些有用的方法。更为强大。
42. Java I/O系统：
	- 任何继承自InputStream或Reader的类都含有read方法，用于读取单个字节或者字节数组。对于不同的数据源，InputStream都提供相应的子类，如FileInputStream专用于从文件中读取信息 **[面向字节]**
	- 任何继承自OutputStream或Writer的类都含有write方法，用于写入单个字节或者字节数组。OutputStream针对不同的输出数据类别，提供相应的子类，如FileOutputStream专用于将信息写入文件 **[面向字节]**
	- FilterInputStream和FilterOutputStream是用来提供装饰器类接口以控制IS和OS的两个类。其中，其子类DataInputStream和DataOutputStream允许读取/写入各种不同的基本数据类型数据以及String对象
	- Reader和Writer类还可以提供**兼容Unicode**与**面向字符**的I/O功能。而InputStream和OutputStream可以通过InputStreamReader和OutputStreamWriter这两个适配器转换成Reader和Writer.
	- 【Tips】尽量尝试使用Reader和Writer，若程序无法成功编译，可知不得不使用面向字节地类库；无论什么时候使用readLine()，都不应该使用DataInputStream，而应该使用BufferedReader。除了这种情况外，DataInputStream仍是I/O类库的首选成员
	- 








<!--stackedit_data:
eyJoaXN0b3J5IjpbMTUwNTk4NzA0OCwxMTQzNTk5NDExLC0zMT
M0Nzk2MzAsLTg0ODg3MzA1NSwxNzYwMjIxMDM1LC0xMTM4MTM3
NjUyLDE4OTM1MDQ2OTgsLTExNDgzMTMzNzYsMjc0NTM5MzU0LD
EyMzMzNjYyMzcsLTI4NTM4Mzc4MywxMjAzODc0NzgwLDEyMTQw
NDcyOTYsLTEzMDcxOTY5NzIsODA2NjU3NjA5LC00NjQ0OTMwMT
csMTExMDIwOTY4LC0xNDE0NTQ0MjcwLDE1ODgzOTAxMjEsLTE1
NDE5NDM2OTJdfQ==
-->